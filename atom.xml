<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A love tip every day</title>
  
  <subtitle>Love Class</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-10-05T11:17:46.373Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Rivner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>css选择器有哪些？优先级？哪些属性可以继承？</title>
    <link href="http://example.com/2018/06/02/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/"/>
    <id>http://example.com/2018/06/02/css%E9%80%89%E6%8B%A9%E5%99%A8%E6%9C%89%E5%93%AA%E4%BA%9B%EF%BC%9F%E4%BC%98%E5%85%88%E7%BA%A7%EF%BC%9F%E5%93%AA%E4%BA%9B%E5%B1%9E%E6%80%A7%E5%8F%AF%E4%BB%A5%E7%BB%A7%E6%89%BF%EF%BC%9F/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2022-10-05T11:17:46.373Z</updated>
    
    <content type="html"><![CDATA[<p>关于css属性选择器常用的有：</p><p>id选择器（#box），选择id为box的元素</p><p>类选择器（.one），选择类名为one的所有元素</p><p>标签选择器（div），选择标签为div的所有元素</p><p>伪类选择器</p><p>伪元素选择器</p><p>属性选择器</p><p>优先级：内联 &gt; ID选择器 &gt; 类选择器 &gt; 标签选择器</p><p>关于继承属性，可以分成：</p><p>字体系列属性</p><p>文本系列属性</p><p>元素可见性</p><p>表格布局属性</p><p>列表属性</p><p>光标属性</p><p>继承中比较特殊的几点：</p><p>a 标签的字体颜色不能被继承</p><p>h1-h6标签字体的大下也是不能被继承的</p><p>无继承的属性</p><p>display</p><p>文本属性：vertical-align、text-decoration</p><p>盒子模型的属性：宽度、高度、内外边距、边框等</p><p>背景属性：背景图片、颜色、位置等</p><p>定位属性：浮动、清除浮动、定位position等</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;关于css属性选择器常用的有：&lt;/p&gt;
&lt;p&gt;id选择器（#box），选择id为box的元素&lt;/p&gt;
&lt;p&gt;类选择器（.one），选择类名为one的所有元素&lt;/p&gt;
&lt;p&gt;标签选择器（div），选择标签为div的所有元素&lt;/p&gt;
&lt;p&gt;伪类选择器&lt;/p&gt;
&lt;p&gt;伪元素选择器</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>什么是模块化</title>
    <link href="http://example.com/2018/06/02/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96/"/>
    <id>http://example.com/2018/06/02/%E4%BB%80%E4%B9%88%E6%98%AF%E6%A8%A1%E5%9D%97%E5%8C%96/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2022-10-05T11:15:20.711Z</updated>
    
    <content type="html"><![CDATA[<p>模块化是指 解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程, 有多种属性,分别反映其内部特性 (百度)</p><p> 　 模块化一般是指 可以被<strong>抽象封装的最小或最优代码的集合 ,</strong> 模块化用于解决<strong>功能耦合问题</strong></p><p>   前端模块化 一般是指javaScript 的模块化 比较常见的就是 node.js 的NPM包 每个模块可以是最小或最优的代码组合 也可以是为了解决某些问题多个小模块合并的一个大的模块 </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;模块化是指 解决一个复杂问题时自顶向下逐层把系统划分成若干模块的过程, 有多种属性,分别反映其内部特性 (百度)&lt;/p&gt;
&lt;p&gt; 　 模块化一般是指 可以被&lt;strong&gt;抽象封装的最小或最优代码的集合 ,&lt;/strong&gt; 模块化用于解决&lt;strong&gt;功能耦合问题&lt;/s</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>什么是盒子模型</title>
    <link href="http://example.com/2018/06/02/%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/"/>
    <id>http://example.com/2018/06/02/%E4%BB%80%E4%B9%88%E6%98%AF%E7%9B%92%E5%AD%90%E6%A8%A1%E5%9E%8B/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2022-10-05T11:16:42.392Z</updated>
    
    <content type="html"><![CDATA[<p>IE盒模型又叫怪异盒模型。在IE8以上以及其他的浏览器中使用的盒模型都是标准盒模型，但是IE低版本使用的是IE盒模型。</p><p>有两种， IE盒子模型（怪异盒子模型）、W3C盒子模型（标准盒子模型）；</p><p>盒模型： 内容(content)、填充(padding)、边界(margin)、 边框(border)；</p><p>区 别： IE的content部分把 border 和 padding计算了进去;</p><p>盒子模型构成：内容(content)、内填充(padding)、 边框(border)、外边距(margin)</p><p>IE8及其以下版本浏览器，未声明 DOCTYPE，内容宽高会包含内填充和边框，称为怪异盒模型(IE盒模型)</p><p>标准(W3C)盒模型：元素宽度 = width + padding + border + margin</p><p>怪异(IE)盒模型：元素宽度 = width + margin</p><p>标准浏览器通过设置 css3 的 box-sizing: border-box 属性，触发“怪异模式”解析计算宽高</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;IE盒模型又叫怪异盒模型。在IE8以上以及其他的浏览器中使用的盒模型都是标准盒模型，但是IE低版本使用的是IE盒模型。&lt;/p&gt;
&lt;p&gt;有两种， IE盒子模型（怪异盒子模型）、W3C盒子模型（标准盒子模型）；&lt;/p&gt;
&lt;p&gt;盒模型： 内容(content)、填充(paddin</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>什么是组件化</title>
    <link href="http://example.com/2018/06/02/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%E5%8C%96/"/>
    <id>http://example.com/2018/06/02/%E4%BB%80%E4%B9%88%E6%98%AF%E7%BB%84%E4%BB%B6%E5%8C%96/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2022-10-05T11:13:01.698Z</updated>
    
    <content type="html"><![CDATA[<p>组件化就是将一个页面拆分成一个个小的功能模块，每个功能模块完成属于自己这部分独立的功能，使得整个页面的管理和维护变得非常容易</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;组件化就是将一个页面拆分成一个个小的功能模块，每个功能模块完成属于自己这部分独立的功能，使得整个页面的管理和维护变得非常容易&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>浏览器的缓存机制</title>
    <link href="http://example.com/2018/06/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2018/06/02/%E6%B5%8F%E8%A7%88%E5%99%A8%E7%9A%84%E7%BC%93%E5%AD%98%E6%9C%BA%E5%88%B6/</id>
    <published>2018-06-01T16:00:00.000Z</published>
    <updated>2022-10-05T11:10:54.486Z</updated>
    
    <content type="html"><![CDATA[<p>浏览器缓存分为:强缓存和协商缓存</p><h3 id="强缓存"><a href="#强缓存" class="headerlink" title="*强缓存*"></a><em><strong>*强缓存*</strong></em></h3><p>这里的’强’是强制的意思,当浏览器去请求某个文件的时候,服务端就在响应头里面对该文件做了缓存配置,缓存的时间,缓存类型都由服务端控制</p><p>可以简单的理解为 ：强缓存会去本地进行请求不会去服务器进行请求</p><p>协商缓存：会先去服务器请求数据 但 服务器没有发生变化的时候在去本地进行请求</p><p>协商缓存</p><p>上面说到的强缓存就是给资源设置个过期时间，客户端每次请求资源时都会看是否过期；只有在过期才会去询问服务器。所以，强缓存就是为了给客户端自给自足用的。而当某天，客户端请求该资源时发现其过期了，这是就会去请求服务器了，而这时候去请求服务器的这过程就可以设置协商缓存。这时候，协商缓存就是需要客户端和服务器两端进行交互的。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;浏览器缓存分为:强缓存和协商缓存&lt;/p&gt;
&lt;h3 id=&quot;强缓存&quot;&gt;&lt;a href=&quot;#强缓存&quot; class=&quot;headerlink&quot; title=&quot;*强缓存*&quot;&gt;&lt;/a&gt;&lt;em&gt;&lt;strong&gt;*强缓存*&lt;/strong&gt;&lt;/em&gt;&lt;/h3&gt;&lt;p&gt;这里的’强’是强制的意思</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Promise是什么，有什么作用？</title>
    <link href="http://example.com/2018/05/30/Promise%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/"/>
    <id>http://example.com/2018/05/30/Promise%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</id>
    <published>2018-05-29T16:00:00.000Z</published>
    <updated>2022-10-05T11:05:35.557Z</updated>
    
    <content type="html"><![CDATA[<p><code>Promise</code>是<code>ES6</code>引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的<code>API</code>，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用</p><p>1.异步操作的解决方案</p><p>Promise 是一种异步操作的解决方案，将写法复杂的传统的回调函数和监听事件的异</p><p>步操作，用同步代码的形式表达出来。避免了多级异步操作的回调函数嵌套。</p><p>主要用于异步计算</p><ol start="2"><li>作为对象，内部有三种状态</li></ol><p>初始状态（ pending ）。</p><p>已完成（ resolve）：resolve 方法可以使 Promise 对象的状态改变成成功</p><p>已拒绝（ reject ）：reject 方法则是将 Promise 对象的状态改变为失败</p><p>3.常用的三种方法</p><p>第一种：then 表示异步成功执行后的数据状态变为 resolve</p><p>第二种：catch 表示异步失败后执行的数据状态变为 reject</p><p>第三种：all 表示把多个没有关系的 Promise 封装成一个 Promise 对象，使用</p><p>then 返回一个数组数据。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;code&gt;Promise&lt;/code&gt;是&lt;code&gt;ES6&lt;/code&gt;引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的&lt;code&gt;API&lt;/code&gt;，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>vue中的data为什么不是一个对象而是一个函数？</title>
    <link href="http://example.com/2018/05/30/vue%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%80%8C%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F/"/>
    <id>http://example.com/2018/05/30/vue%E4%B8%AD%E7%9A%84data%E4%B8%BA%E4%BB%80%E4%B9%88%E4%B8%8D%E6%98%AF%E4%B8%80%E4%B8%AA%E5%AF%B9%E8%B1%A1%E8%80%8C%E6%98%AF%E4%B8%80%E4%B8%AA%E5%87%BD%E6%95%B0%EF%BC%9F/</id>
    <published>2018-05-29T16:00:00.000Z</published>
    <updated>2022-10-05T11:07:53.909Z</updated>
    
    <content type="html"><![CDATA[<p>因为组件是用来复用的，且JS对象是引用关系，如果组件中的data是对象，那么作用域没有隔离</p><p>组件中的data值会相互影响；如果组件中data是函数，那么每个实例可以维护一份被返回对象</p><p>的独立拷贝，组件实例之间的data值不会相互影响。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;因为组件是用来复用的，且JS对象是引用关系，如果组件中的data是对象，那么作用域没有隔离&lt;/p&gt;
&lt;p&gt;组件中的data值会相互影响；如果组件中data是函数，那么每个实例可以维护一份被返回对象&lt;/p&gt;
&lt;p&gt;的独立拷贝，组件实例之间的data值不会相互影响。&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>如何理解Bight</title>
    <link href="http://example.com/2018/05/24/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Bight/"/>
    <id>http://example.com/2018/05/24/%E5%A6%82%E4%BD%95%E7%90%86%E8%A7%A3Bight/</id>
    <published>2018-05-23T16:00:00.000Z</published>
    <updated>2022-10-04T23:58:57.472Z</updated>
    
    <content type="html"><![CDATA[<h3 id="如何理解BigInt"><a href="#如何理解BigInt" class="headerlink" title="如何理解BigInt"></a>如何理解BigInt</h3><p><strong>什么是BigInt?</strong></p><blockquote><p><code>BigInt</code>是一种新的数据类型，用于当整数值大于Number数据类型支持的范围时。这种数据类型允许我们安全地对大整数执行算术操作，表示高分辨率的时间戳，使用大整数id，等等，而不需要使用库。</p></blockquote><p><strong>为什么需要BigInt?</strong></p><p>在JS中，所有的数字都以双精度64位浮点格式表示，那这会带来什么问题呢？</p><blockquote><p>这导致JS中的Number无法精确表示非常大的整数，它会将非常大的整数四舍五入，确切地说，JS中的<code>Number</code>类型只能安全地表示<code>-9007199254740991(-(2^53-1))和9007199254740991（(2^53-1)）</code>，任何超出此范围的整数值都可能失去精度。</p></blockquote><p><strong>如何创建并使用BigInt？</strong></p><p>要创建<code>BigInt</code>，只需要在数字末尾追加<code>n</code>即可</p><p>console.log( 9007199254740995n );    // → 9007199254740995n<br>console.log( 9007199254740995 );     // → 9007199254740996</p><p>另一种创建<code>BigInt</code>的方法是用<code>BigInt()</code>构造函数</p><p>BigInt(“9007199254740995”);    // → 9007199254740995n</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;如何理解BigInt&quot;&gt;&lt;a href=&quot;#如何理解BigInt&quot; class=&quot;headerlink&quot; title=&quot;如何理解BigInt&quot;&gt;&lt;/a&gt;如何理解BigInt&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;什么是BigInt?&lt;/strong&gt;&lt;/p&gt;
&lt;block</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>typeof和instanceof的区别</title>
    <link href="http://example.com/2018/05/24/typeof%E5%92%8Cinstanceof%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/05/24/typeof%E5%92%8Cinstanceof%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-05-23T16:00:00.000Z</published>
    <updated>2022-10-04T23:58:37.520Z</updated>
    
    <content type="html"><![CDATA[<h3 id="typeof-于-instanceof-区别"><a href="#typeof-于-instanceof-区别" class="headerlink" title="typeof 于 instanceof 区别"></a>typeof 于 instanceof 区别</h3><blockquote><p><code>typeof</code> 对于基本类型，除了 <code>null</code>都可以显示正确的类型    </p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">typeof` 对于对象，除了函数都会显示 `object</span><br></pre></td></tr></table></figure></blockquote><p>​    对于 <code>null</code> 来说，虽然它是基本类型，但是会显示 <code>object</code>，这是一个存在很久了的 <code>Bug</code></p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">instanceof` 可以正确的判断对象的类型，因为内部机制是通过判断对象的原型链中是不是能找到类型的 `iprototype</span><br></pre></td></tr></table></figure><h3 id="和-有什么区别"><a href="#和-有什么区别" class="headerlink" title="== 和 ===有什么区别"></a>== 和 ===有什么区别</h3><p>​        </p><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">===`叫做严格相等，是指：左右两边不仅值要相等，类型也要相等，例如`&#x27;1&#x27;===1`的结果是`false`，因为一边是`string`，另一边是`number</span><br></pre></td></tr></table></figure></blockquote><p><strong>==不像===那样严格，对于一般情况，只要值相等，就返回true，但==还涉及一些类型转换，它的转换规则如下</strong></p><ul><li>两边的类型是否相同，相同的话就比较值的大小，例如<code>1==2</code>，返回<code>false</code></li><li>判断的是否是<code>null</code>和<code>undefined</code>，是的话就返回true</li><li>判断的类型是否是<code>String</code>和<code>Number</code>，是的话，把<code>String</code>类型转换成<code>Number</code>，再进行比较</li><li>判断其中一方是否是<code>Boolean</code>，是的话就把<code>Boolean</code>转换成<code>N</code>umber`，再进行比较</li><li>如果其中一方为<code>Object</code>，且另一方为<code>String</code>、<code>Number</code>或者<code>Symbol</code>，会将<code>Object</code>转换成字符串，再进行比较</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;typeof-于-instanceof-区别&quot;&gt;&lt;a href=&quot;#typeof-于-instanceof-区别&quot; class=&quot;headerlink&quot; title=&quot;typeof 于 instanceof 区别&quot;&gt;&lt;/a&gt;typeof 于 instanceof </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数组常用的方法</title>
    <link href="http://example.com/2018/05/24/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2018/05/24/%E6%95%B0%E7%BB%84%E5%B8%B8%E7%94%A8%E7%9A%84%E6%96%B9%E6%B3%95/</id>
    <published>2018-05-23T16:00:00.000Z</published>
    <updated>2022-10-04T23:59:14.004Z</updated>
    
    <content type="html"><![CDATA[<h3 id="数组常用方法"><a href="#数组常用方法" class="headerlink" title="数组常用方法"></a>数组常用方法</h3><ul><li><code>map</code>: 遍历数组，返回回调返回值组成的新数组</li><li><code>forEach</code>: 无法<code>break</code>，可以用<code>try/catch</code>中<code>throw new Error</code>来停止</li><li><code>filter</code>: 过滤</li><li><code>some</code>: 有一项返回<code>true</code>，则整体为<code>true</code></li><li><code>every</code>: 有一项返回<code>false</code>，则整体为<code>false</code></li><li><code>join</code>: 通过指定连接符生成字符串</li><li><code>push / pop</code>: 末尾推入和弹出，改变原数组， 返回推入/弹出项</li><li><code>unshift / shift</code>: 头部推入和弹出，改变原数组，返回操作项</li><li><code>sort(fn) / reverse</code>: 排序与反转，改变原数组</li><li><code>concat</code>: 连接数组，不影响原数组， 浅拷贝</li><li><code>slice(start, end)</code>: 返回截断后的新数组，不改变原数组</li><li><code>splice(start, number, value...)</code>: 返回删除元素组成的数组，<code>value</code>为插入项，改变原数组</li><li><code>indexOf / lastIndexOf(value, fromIndex)</code>: 查找数组项，返回对应的下标</li><li><code>reduce / reduceRight(fn(prev, cur)</code>， <code>defaultPrev)</code>: 两两执行，<code>prev</code> 为上次化简函数的<code>return</code>值，<code>cur</code>为当前值(从第二项开始)</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;数组常用方法&quot;&gt;&lt;a href=&quot;#数组常用方法&quot; class=&quot;headerlink&quot; title=&quot;数组常用方法&quot;&gt;&lt;/a&gt;数组常用方法&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;code&gt;map&lt;/code&gt;: 遍历数组，返回回调返回值组成的新数组&lt;/li&gt;
&lt;li&gt;&lt;c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Symbol是什么，有什么作用？</title>
    <link href="http://example.com/2018/05/24/Symbol%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/"/>
    <id>http://example.com/2018/05/24/Symbol%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</id>
    <published>2018-05-23T16:00:00.000Z</published>
    <updated>2022-10-04T23:58:23.760Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Symbol是什么，有什么作用？"><a href="#Symbol是什么，有什么作用？" class="headerlink" title="Symbol是什么，有什么作用？"></a>Symbol是什么，有什么作用？</h2><blockquote><p><code>Symbol</code>是<code>ES6</code>引入的第七种原始数据类型（说法不准确，应该是第七种数据类型，Object不是原始数据类型之一，已更正），所有Symbol()生成的值都是独一无二的，可以从根本上解决对象属性太多导致属性名冲突覆盖的问题。对象中<code>Symbol()</code>属性不能被<code>for...in</code>遍历，但是也不是私有属性</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Symbol是什么，有什么作用？&quot;&gt;&lt;a href=&quot;#Symbol是什么，有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;Symbol是什么，有什么作用？&quot;&gt;&lt;/a&gt;Symbol是什么，有什么作用？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>let有什么用 有了var为什么还要用let</title>
    <link href="http://example.com/2018/05/23/let%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8-%E6%9C%89%E4%BA%86var%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8let/"/>
    <id>http://example.com/2018/05/23/let%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8-%E6%9C%89%E4%BA%86var%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8let/</id>
    <published>2018-05-22T16:00:00.000Z</published>
    <updated>2022-10-04T23:57:33.180Z</updated>
    
    <content type="html"><![CDATA[<p>​    <a href="https://interview2.poetries.top/docs/excellent-docs/4-ES6%E6%A8%A1%E5%9D%97.html#_3-let%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8-%E6%9C%89%E4%BA%86var%E4%B8%BA%E4%BB%80%E4%B9%88%E8%BF%98%E8%A6%81%E7%94%A8let">#</a>3 let有什么用，有了var为什么还要用let？</p><blockquote><p>在<code>ES6</code>之前，声明变量只能用<code>var</code>，<code>var</code>方式声明变量其实是很不合理的，准确的说，是因为<code>ES5</code>里面没有块级作用域是很不合理的。没有块级作用域回来带很多难以理解的问题，比如<code>for</code>循环<code>var</code>变量泄露，变量覆盖等问题。<code>let</code>声明的变量拥有自己的块级作用域，且修复了<code>var</code>声明变量带来的变量提升问题。</p></blockquote><p>let和const是<a href="https://so.csdn.net/so/search?q=ES6&spm=1001.2101.3001.7020">ES6</a>新增的声明变量的关键词，之前声明变量的关键词是var。</p><p>let<br>var定义的变量，可以预解析提前调用的结果是undefined，let定义的变量不能预解析，提前调用的结果是 报错。<br>var定义的变量，变量名称可以重复，效果是重复赋值，let定义的变量不能重复，否则执行报错。<br>var定义的变量作用域是全局/局部作用域。let定义的变量如果在{}中只能在{}中调用。<br>在循环语句中var定义的循环变量和使用let定义的循环变量。执行原理和执行效果不同。</p><p>const<br> var定义的变量，可以预解析提前调用的结果是undefined，const定义的变量不能预解析，提前调用的结果是 报错。<br>var定义的变量，变量名称可以重复，效果是重复赋值，const定义的变量不能重复，否则执行报错。<br>var定义的变量作用域是全局/局部作用域。let定义的变量如果在{}中只能在{}中调用。<br>const 定义的变量存储的数据数值不能改变，也就是const定义的变量，不能重复赋值。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;​    &lt;a href=&quot;https://interview2.poetries.top/docs/excellent-docs/4-ES6%E6%A8%A1%E5%9D%97.html#_3-let%E6%9C%89%E4%BB%80%E4%B9%88%E7%94%A8</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Proxy是什么，有什么作用？</title>
    <link href="http://example.com/2018/05/23/Proxy%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/"/>
    <id>http://example.com/2018/05/23/Proxy%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</id>
    <published>2018-05-22T16:00:00.000Z</published>
    <updated>2022-10-04T23:57:58.787Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Proxy是什么，有什么作用？"><a href="#Proxy是什么，有什么作用？" class="headerlink" title="Proxy是什么，有什么作用？"></a>Proxy是什么，有什么作用？</h2><blockquote><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">Proxy`是`ES6`新增的一个构造函数，可以理解为JS语言的一个代理，用来改变JS默认的一些语言行为，包括拦截默认的`get/set`等底层方法，使得JS的使用自由度更高，可以最大限度的满足开发者的需求。比如通过拦截对象的`get/set`方法，可以轻松地定制自己想要的`key`或者`value`。下面的例子可以看到，随便定义一个`myOwnObj`的`key`,都可以变成自己想要的函数</span><br></pre></td></tr></table></figure></blockquote><h2 id="Promise是什么，有什么作用？"><a href="#Promise是什么，有什么作用？" class="headerlink" title="Promise是什么，有什么作用？"></a>Promise是什么，有什么作用？</h2><blockquote><p><code>Promise</code>是<code>ES6</code>引入的一个新的对象，他的主要作用是用来解决JS异步机制里，回调机制产生的“回调地狱”。它并不是什么突破性的<code>API</code>，只是封装了异步回调形式，使得异步回调可以写的更加优雅，可读性更高，而且可以链式调用</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Proxy是什么，有什么作用？&quot;&gt;&lt;a href=&quot;#Proxy是什么，有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;Proxy是什么，有什么作用？&quot;&gt;&lt;/a&gt;Proxy是什么，有什么作用？&lt;/h2&gt;&lt;blockquote&gt;
&lt;figure </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Set是什么，有什么作用？</title>
    <link href="http://example.com/2018/05/23/Set%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/"/>
    <id>http://example.com/2018/05/23/Set%E6%98%AF%E4%BB%80%E4%B9%88%EF%BC%8C%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8%EF%BC%9F/</id>
    <published>2018-05-22T16:00:00.000Z</published>
    <updated>2022-10-04T23:58:11.648Z</updated>
    
    <content type="html"><![CDATA[<h2 id="Set是什么，有什么作用？"><a href="#Set是什么，有什么作用？" class="headerlink" title="Set是什么，有什么作用？"></a>Set是什么，有什么作用？</h2><blockquote><p><code>Set</code>是<code>ES6</code>引入的一种类似<code>Array</code>的新的数据结构，<code>Set</code>实例的成员类似于数组<code>item</code>成员，区别是<code>Set</code>实例的成员都是唯一，不重复的。这个特性可以轻松地实现数组去重</p></blockquote><h2 id="Map是什么，有什么作用？"><a href="#Map是什么，有什么作用？" class="headerlink" title="Map是什么，有什么作用？"></a>Map是什么，有什么作用？</h2><blockquote><p><code>Map</code>是<code>ES6</code>引入的一种类似<code>Object</code>的新的数据结构，<code>Map</code>可以理解为是<code>Object</code>的超集，打破了以传统键值对形式定义对象，对象的<code>key</code>不再局限于字符串，也可以是<code>Object</code>。可以更加全面的描述对象的属性</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;Set是什么，有什么作用？&quot;&gt;&lt;a href=&quot;#Set是什么，有什么作用？&quot; class=&quot;headerlink&quot; title=&quot;Set是什么，有什么作用？&quot;&gt;&lt;/a&gt;Set是什么，有什么作用？&lt;/h2&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;code&gt;Set&lt;/co</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Dom常用方法</title>
    <link href="http://example.com/2018/05/22/Dom%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/"/>
    <id>http://example.com/2018/05/22/Dom%E5%B8%B8%E7%94%A8%E6%96%B9%E6%B3%95/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2022-10-04T23:56:44.023Z</updated>
    
    <content type="html"><![CDATA[<h3 id="说说有几种类型的DOM节点"><a href="#说说有几种类型的DOM节点" class="headerlink" title="说说有几种类型的DOM节点"></a>说说有几种类型的DOM节点</h3><ul><li><p><code>Document</code>节点，整个文档是一个文档节点；</p></li><li><p><code>Element</code>节点，每个HTML标签是一个元素节点；</p></li><li><p><code>Attribute</code>节点，每一个HTML属性是一个属性节点；</p></li><li><p><code>Text</code>节点，包含在HTML元素中的文本是文本节点</p><h3 id="操作DOM节点方法"><a href="#操作DOM节点方法" class="headerlink" title="操作DOM节点方法"></a>操作DOM节点方法</h3><p>创建新节点</p><p>​        createDocumentFragment()    //创建一个DOM片段<br>​        createElement()   //创建一个具体的元素<br>​        createTextNode()   //创建一个文本节点</p><p>添加、移除、替换、插入**</p><p>​        appendChild()      //添加<br>​        removeChild()      //移除<br>​        replaceChild()      //替换<br>​        insertBefore()      //插入</p></li></ul><p>​    <strong>查找</strong></p><pre><code>        getElementsByTagName()    //通过标签名称</code></pre><p>​                    getElementsByName()     //通过元素的Name属性的值<br>​                    getElementById()        //通过元素Id，唯一性</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;说说有几种类型的DOM节点&quot;&gt;&lt;a href=&quot;#说说有几种类型的DOM节点&quot; class=&quot;headerlink&quot; title=&quot;说说有几种类型的DOM节点&quot;&gt;&lt;/a&gt;说说有几种类型的DOM节点&lt;/h3&gt;&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;code&gt;Document&lt;/c</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>js类型判断</title>
    <link href="http://example.com/2018/05/22/js%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/"/>
    <id>http://example.com/2018/05/22/js%E7%B1%BB%E5%9E%8B%E5%88%A4%E6%96%AD/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2022-10-04T23:57:18.324Z</updated>
    
    <content type="html"><![CDATA[<h3 id="typeof类型判断"><a href="#typeof类型判断" class="headerlink" title="typeof类型判断"></a>typeof类型判断</h3><p>​    在写业务逻辑的时候，经常要用到JS数据类型的判断，面试常见的案例深浅拷贝也要用到数据类型的判断。</p><p><strong>typeof</strong></p><pre><code>console.log(typeof 2);               // number</code></pre><p>console.log(typeof true);            // boolean<br>console.log(typeof ‘str’);           // string<br>console.log(typeof undefined);       // undefined<br>console.log(typeof function(){});    // function<br>console.log(typeof Symbol(“foo”)); // symbol<br>console.log(typeof 2172141653n); // bigint</p><p>// 不能判别<br>console.log(typeof []); // object<br>console.log(typeof {}); // object<br>console.log(typeof null); // object</p><p>优点：能够快速区分基本数据类型 缺点：不能将<code>Object</code>、<code>Array</code>和<code>Null</code>区分，都返回<code>object</code></p><p><strong>instanceof</strong></p><pre><code>console.log(2 instanceof Number);                    // false</code></pre><p>console.log(true instanceof Boolean);                // false<br>console.log(‘str’ instanceof String);                // false<br>console.log([] instanceof Array);                    // true<br>console.log(function(){} instanceof Function);       // true<br>console.log({} instanceof Object);                   // true</p><ul><li>优点：能够区分<code>Array</code>、<code>Object</code>和<code>Function</code>，适合用于判断自定义的类实例对象</li><li>缺点：<code>Number</code>，<code>Boolean</code>，<code>String</code>基本数据类型不能判断</li></ul><blockquote><p>其内部运行机制是判断在其原型链中能否找到该类型的原型其实现就是顺着原型链去找，如果能找到对应的 <code>Xxxxx.prototype</code> 即为 <code>true</code> 。比如这里的 <code>stu</code> 作为实例，顺着原型链能找到 <code>Student.prototype</code> 及 <code>People.prototype</code> ，所以都为 <code>true</code></p></blockquote><p><strong>Object.prototype.toString.call()</strong></p><pre><code>var toString = Object.prototype.toString;</code></pre><p>console.log(toString.call(2));                      //[object Number]<br>console.log(toString.call(true));                   //[object Boolean]<br>console.log(toString.call(‘str’));                  //[object String]<br>console.log(toString.call([]));                     //[object Array]<br>console.log(toString.call(function(){}));           //[object Function]<br>console.log(toString.call({}));                     //[object Object]<br>console.log(toString.call(undefined));              //[object Undefined]<br>console.log(toString.call(null));                   //[object Null]</p><p>优点：精准判断数据类型，所有原始数据类型都是能判断的，还有 <code>Error</code> 对象，<code>Date</code> 对象等</p><p>缺点：写法繁琐不容易记，推荐进行封装后使用</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;typeof类型判断&quot;&gt;&lt;a href=&quot;#typeof类型判断&quot; class=&quot;headerlink&quot; title=&quot;typeof类型判断&quot;&gt;&lt;/a&gt;typeof类型判断&lt;/h3&gt;&lt;p&gt;​    在写业务逻辑的时候，经常要用到JS数据类型的判断，面试常见的案例深</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Ajax有哪些有缺点</title>
    <link href="http://example.com/2018/05/22/Ajax%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E7%BC%BA%E7%82%B9/"/>
    <id>http://example.com/2018/05/22/Ajax%E6%9C%89%E5%93%AA%E4%BA%9B%E6%9C%89%E7%BC%BA%E7%82%B9/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2022-10-04T23:56:26.561Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Ajax-有那些优缺点"><a href="#Ajax-有那些优缺点" class="headerlink" title="Ajax 有那些优缺点"></a>Ajax 有那些优缺点</h3><p><strong>优点：</strong></p><ul><li>通过异步模式，提升了用户体验.</li><li>优化了浏览器和服务器之间的传输，减少不必要的数据往返，减少了带宽占用.</li><li><code>Ajax</code>在客户端运行，承担了一部分本来由服务器承担的工作，减少了大用户量下的服务器负载。</li><li><code>Ajax</code>可以实现动态不刷新（局部刷新）</li></ul><p><strong>缺点：</strong></p><ul><li>安全问题 <code>AJAX</code>暴露了与服务器交互的细节。</li><li>对搜索引擎的支持比较弱。</li><li>不容易调试。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Ajax-有那些优缺点&quot;&gt;&lt;a href=&quot;#Ajax-有那些优缺点&quot; class=&quot;headerlink&quot; title=&quot;Ajax 有那些优缺点&quot;&gt;&lt;/a&gt;Ajax 有那些优缺点&lt;/h3&gt;&lt;p&gt;&lt;strong&gt;优点：&lt;/strong&gt;&lt;/p&gt;
&lt;ul&gt;
&lt;li&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>Es5 Es6和E2015有什么区别</title>
    <link href="http://example.com/2018/05/22/Es5-Es6%E5%92%8CE2015%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/05/22/Es5-Es6%E5%92%8CE2015%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB/</id>
    <published>2018-05-21T16:00:00.000Z</published>
    <updated>2022-10-04T23:56:58.322Z</updated>
    
    <content type="html"><![CDATA[<h2 id="1-ES5、ES6和ES2015有什么区别"><a href="#1-ES5、ES6和ES2015有什么区别" class="headerlink" title="#1 ES5、ES6和ES2015有什么区别?"></a><a href="https://interview2.poetries.top/docs/excellent-docs/4-ES6%E6%A8%A1%E5%9D%97.html#_1-es5%E3%80%81es6%E5%92%8Ces2015%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB">#</a>1 ES5、ES6和ES2015有什么区别?</h2><blockquote><p><code>ES2015</code>特指在<code>2015</code>年发布的新一代<code>JS</code>语言标准，<code>ES6</code>泛指下一代JS语言标准，包含<code>ES2015</code>、<code>ES2016</code>、<code>ES2017</code>、<code>ES2018</code>等。现阶段在绝大部分场景下，<code>ES2015</code>默认等同<code>ES6</code>。<code>ES5</code>泛指上一代语言标准。<code>ES2015</code>可以理解为<code>ES5</code>和<code>ES6</code>的时间分界线</p></blockquote><h2 id="2-babel是什么，有什么作用"><a href="#2-babel是什么，有什么作用" class="headerlink" title="#2 babel是什么，有什么作用?"></a><a href="https://interview2.poetries.top/docs/excellent-docs/4-ES6%E6%A8%A1%E5%9D%97.html#_2-babel%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8">#</a>2 babel是什么，有什么作用?</h2><blockquote><p><code>babel</code>是一个 <code>ES6</code> 转码器，可以将 <code>ES6</code> 代码转为 <code>ES5</code> 代码，以便兼容那些还没支持<code>ES6</code>的平台</p></blockquote><h2 id="3-举一些ES6对Array数组类型做的常用升级优化"><a href="#3-举一些ES6对Array数组类型做的常用升级优化" class="headerlink" title="3 举一些ES6对Array数组类型做的常用升级优化"></a>3 举一些ES6对Array数组类型做的常用升级优化</h2><p><strong>优化部分</strong></p><ul><li>数组解构赋值。<code>ES6</code>可以直接以<code>let [a,b,c] = [1,2,3]</code>形式进行变量赋值，在声明较多变量时，不用再写很多<code>let(var),</code>且映射关系清晰，且支持赋默认值</li><li>扩展运算符。<code>ES6</code>新增的扩展运算符(<code>...</code>)(重要),可以轻松的实现数组和松散序列的相互转化，可以取代<code>arguments</code>对象和<code>apply</code>方法，轻松获取未知参数个数情况下的参数集合。（尤其是在<code>ES5</code>中，<code>arguments</code>并不是一个真正的数组，而是一个类数组的对象，但是扩展运算符的逆运算却可以返回一个真正的数组）。扩展运算符还可以轻松方便的实现数组的复制和解构赋值（<code>let a = [2,3,4]</code>; <code>let b = [...a]</code>）</li></ul><p><strong>升级部分</strong></p><blockquote><p><code>ES6</code>在<code>Array</code>原型上新增了<code>find()</code>方法，用于取代传统的只能用<code>indexOf</code>查找包含数组项目的方法,且修复了<code>indexOf</code>查找不到<code>NaN的bug([NaN].indexOf(NaN) === -1)</code>.此外还新增了<code>copyWithin()</code>,<code>includes()</code>, <code>fill()</code>,<code>flat()</code>等方法，可方便的用于字符串的查找，补全,转换等</p></blockquote>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;1-ES5、ES6和ES2015有什么区别&quot;&gt;&lt;a href=&quot;#1-ES5、ES6和ES2015有什么区别&quot; class=&quot;headerlink&quot; title=&quot;#1 ES5、ES6和ES2015有什么区别?&quot;&gt;&lt;/a&gt;&lt;a href=&quot;https://inte</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>数据类型基础</title>
    <link href="http://example.com/2018/05/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/"/>
    <id>http://example.com/2018/05/20/%E5%9F%BA%E7%A1%80%E6%95%B0%E6%8D%AE%E7%B1%BB%E5%9E%8B/</id>
    <published>2018-05-20T08:55:34.000Z</published>
    <updated>2022-10-04T11:43:31.264Z</updated>
    
    <content type="html"><![CDATA[<ul><li><p><input disabled="" type="checkbox">  一 <code>JS</code> 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（<code>Object</code>）。</p></li><li><p><input disabled="" type="checkbox">  基本类型有七种：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">null</span><br></pre></td></tr></table></figure><p>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">undefined</span><br></pre></td></tr></table></figure><p>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">boolean</span><br></pre></td></tr></table></figure><p>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">number</span><br></pre></td></tr></table></figure><p>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">string</span><br></pre></td></tr></table></figure><p>，</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">symbol</span><br></pre></td></tr></table></figure><p>,</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">bigint</span><br></pre></td></tr></table></figure><ul><li>其中 <code>Symbo</code>l 和 <code>BigInt</code> 是 <code>ES6</code> 新增的数据类型</li><li><code>Symbol</code> 代表独一无二的值，最大的用法是用来定义对象的唯一属性名。</li><li><code>BigInt</code> 可以表示任意大小的整数。</li></ul></li><li><p><input disabled="" type="checkbox">  其中 <code>JS</code> 的数字类型是浮点类型的，没有整型。并且浮点类型基于 <code>IEEE 754</code>标准实现，在使用中会遇到某些 Bug。<code>NaN</code> 也属于 <code>number</code> 类型，并且 <code>NaN</code> 不等于自身。</p></li><li><p><input disabled="" type="checkbox">  对于基本类型来说，如果使用字面量的方式，那么这个变量只是个字面量，只有在必要的时候才会转换为对应的类型</p></li></ul><p><strong>引用数据类型:</strong></p><ul><li>对象<code>Object</code>（包含普通对象-<code>Object</code>，数组对象-<code>Array</code>，正则对象-<code>RegExp</code>，日期对象-<code>Date</code>，数学函数-<code>Math</code>，函数对象-<code>Function</code>）</li></ul><p>​    对象（<code>Object</code>）是引用类型，在使用过程中会遇到浅拷贝和深拷贝的问题。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;p&gt;&lt;input disabled=&quot;&quot; type=&quot;checkbox&quot;&gt;  一 &lt;code&gt;JS&lt;/code&gt; 中分为七种内置类型，七种内置类型又分为两大类型：基本类型和对象（&lt;code&gt;Object&lt;/code&gt;）。&lt;/p&gt;
&lt;/li&gt;
&lt;li&gt;&lt;p&gt;&lt;i</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title>null和undefined的区别</title>
    <link href="http://example.com/2018/05/20/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/05/20/null%E5%92%8Cundefined%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-05-19T16:00:00.000Z</published>
    <updated>2022-10-04T13:30:24.824Z</updated>
    
    <content type="html"><![CDATA[<h3 id="null和undefined区别"><a href="#null和undefined区别" class="headerlink" title="null和undefined区别"></a>null和undefined区别</h3><blockquote><p><code>Undefined</code>类型只有一个值，即<code>undefined</code>。当声明的变量还未被初始化时，变量的默认值为<code>undefined</code>。用法</p></blockquote><ul><li>变量被声明了，但没有赋值时，就等于<code>undefined</code>。</li><li>调用函数时，应该提供的参数没有提供，该参数等于<code>undefined</code>。</li><li>对象没有赋值的属性，该属性的值为<code>undefined</code>。</li><li>函数没有返回值时，默认返回<code>undefined</code></li></ul><blockquote><p><code>Null</code>类型也只有一个值，即<code>null</code>。<code>null</code>用来表示尚未存在的对象，常用来表示函数企图返回一个不存在的对象。用法</p></blockquote><ul><li>作为函数的参数，表示该函数的参数不是对象。</li><li>作为对象原型链的终点</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;null和undefined区别&quot;&gt;&lt;a href=&quot;#null和undefined区别&quot; class=&quot;headerlink&quot; title=&quot;null和undefined区别&quot;&gt;&lt;/a&gt;null和undefined区别&lt;/h3&gt;&lt;blockquote&gt;
&lt;p&gt;&lt;</summary>
      
    
    
    
    
  </entry>
  
</feed>
