<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>A love tip every day</title>
  
  <subtitle>Love Class</subtitle>
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2022-11-01T07:06:54.581Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>Rivner</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title>vue2和vue3的区别</title>
    <link href="http://example.com/2018/09/30/vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/09/30/vue2%E5%92%8Cvue3%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-09-29T16:00:00.000Z</published>
    <updated>2022-11-01T07:06:54.581Z</updated>
    
    <content type="html"><![CDATA[<p>\1. vue2和vue3双向数据绑定原理发生了改变</p><p>vue2的双向数据绑定是利用了es5 的一个API Object.definepropert() 对数据进行劫持 结合发布订阅模式来实现的。vue3中使用了es6的proxyAPI对数据进行处理。</p><p>相比与vue2，使用proxy API 优势有：defineProperty只能监听某个属性，不能对全对象进行监听；可以省去for in 、闭包等内容来提升效率（直接绑定整个对象即可）；可以监听数组，不用再去单独的对数组做特异性操作，vue3可以检测到数组内部数据的变化。</p><p>2.Vue3支持碎片（Fragments）</p><p>就是说可以拥有多个跟节点。</p><p>1</p><p>\3. Composition API</p><p>Vue2 与vue3 最大的区别是vue2使用选项类型api，对比vue3合成型api。旧得选项型api在代码里分割了不同得属性：data,computed,methods等；新得合成型api能让我们使用方法来分割，相比于旧的API使用属性来分组，这样代码会更加简便和整洁。</p><p>\4. 建立数据data</p><p>vue2是把数据放入data中，vue3就需要使用一个新的setup()方法，此方法在组件初始化构造得时候触发。使用一下三个步骤来简=建立反应性数据： 1. 从vue引入reactive；使用reactive() 方法来声明数据为响应性数据；3. 使用setup()方法来返回我们得响应性数据，从而template可以获取这些响应性数据。</p><p>1</p><p>\5. 生命周期</p><p>vue2   ————— vue3</p><p>beforeCreate             -&gt;  setup()</p><p>Created                 -&gt;  setup()</p><p>beforeMount              -&gt;  onBeforeMount</p><p>mounted                 -&gt;   onMounted</p><p>beforeUpdate             -&gt;   onBeforeUpdate</p><p>updated                 -&gt;   onUpdated</p><p>beforeDestroyed           -&gt;   onBeforeUnmount</p><p>destroyed                -&gt;   onUnmounted</p><p>activated                 -&gt;   onActivated</p><p>deactivated               -&gt;   onDeactivated</p><p>\6. 父子传参不同，setup()函数特性</p><p>setup()函数接收两个参数：props、context(包含attrs、slots、emit)</p><p>setup函数是处于生命周期beforeCreated和created俩个钩子函数之前</p><p>执行setup时，组件实例尚未被创建（在setup()内部，this不会是该活跃实例得引用，即不指向vue实例，Vue为了避免我们错误得使用，直接将setup函数中得this修改成了undefined）</p><p>与模板一起使用时，需要返回一个对象</p><p>因为setup函数中，props是响应式得，当传入新的prop时，它将会被更新，所以不能使用es6解构，因为它会消除prop得响应性，如需解构prop，可以通过使用setup函数中得toRefs来完成此操作。</p><p>父传子，用props,子传父用事件 Emitting Events。在vue2中，会调用this$emit然后传入事件名和对象；在vue3中得setup()中得第二个参数content对象中就有emit，那么我们只要在setup()接收第二个参数中使用分解对象法取出emit就可以在setup方法中随意使用了。</p><p>在setup()内使用响应式数据时，需要通过 .value 获取</p><p>import { ref } from ‘vue’</p><p>const count = ref(0)</p><p>console.log(count.value)</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;\1. vue2和vue3双向数据绑定原理发生了改变&lt;/p&gt;
&lt;p&gt;vue2的双向数据绑定是利用了es5 的一个API Object.definepropert() 对数据进行劫持 结合发布订阅模式来实现的。vue3中使用了es6的proxyAPI对数据进行处理。&lt;/p&gt;
</summary>
      
    
    
    
    <category term="-Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="-Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>你了解vue的diff算法吗？说说看</title>
    <link href="http://example.com/2018/09/16/41-%E4%BD%A0%E4%BA%86%E8%A7%A3vue%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%9C%8B/"/>
    <id>http://example.com/2018/09/16/41-%E4%BD%A0%E4%BA%86%E8%A7%A3vue%E7%9A%84diff%E7%AE%97%E6%B3%95%E5%90%97%EF%BC%9F%E8%AF%B4%E8%AF%B4%E7%9C%8B/</id>
    <published>2018-09-15T16:00:00.000Z</published>
    <updated>2022-11-01T07:05:50.141Z</updated>
    
    <content type="html"><![CDATA[<p>diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点</p><p>不同的地方，最后用patch记录的消息去局部更新Dom。</p><p>其有两个特点：</p><p>比较只会在同层级进行, 不会跨层级比较</p><p>在diff比较的过程中，循环从两边向中间比较</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;diff算法就是进行虚拟节点对比，并返回一个patch对象，用来存储两个节点&lt;/p&gt;
&lt;p&gt;不同的地方，最后用patch记录的消息去局部更新Dom。&lt;/p&gt;
&lt;p&gt;其有两个特点：&lt;/p&gt;
&lt;p&gt;比较只会在同层级进行, 不会跨层级比较&lt;/p&gt;
&lt;p&gt;在diff比较的过程中，循</summary>
      
    
    
    
    <category term="-Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="-Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue中组件和插件有什么区别？</title>
    <link href="http://example.com/2018/09/01/Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/"/>
    <id>http://example.com/2018/09/01/Vue%E4%B8%AD%E7%BB%84%E4%BB%B6%E5%92%8C%E6%8F%92%E4%BB%B6%E6%9C%89%E4%BB%80%E4%B9%88%E5%8C%BA%E5%88%AB%EF%BC%9F/</id>
    <published>2018-08-31T16:00:00.000Z</published>
    <updated>2022-11-01T07:03:40.857Z</updated>
    
    <content type="html"><![CDATA[<p>组件注册通过“Vue.component”或“components”属性，而插件通过“Vue.use()”；2、组件是用来构成App的业务模块，它的目标是“App.vue”，而插件是用来增强技术栈的功能模块，它的目标是Vue本身。</p><p>Cvb常见使用场景可以分为三类：</p><p>父子通信：</p><p>父向子传递数据是通过 props，子向父是通过 events（$emit）；通过父链 / 子链也可以通信（$parent / $children）；ref 也可以访问组件实例；provide / inject API；$attrs/$listeners</p><p>兄弟通信：</p><p>Bus；Vuex</p><p>跨级通信：</p><p>Bus；Vuex；provide / inject API、$attrs/$listeners</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;组件注册通过“Vue.component”或“components”属性，而插件通过“Vue.use()”；2、组件是用来构成App的业务模块，它的目标是“App.vue”，而插件是用来增强技术栈的功能模块，它的目标是Vue本身。&lt;/p&gt;
&lt;p&gt;Cvb常见使用场景可以分为三</summary>
      
    
    
    
    <category term="-Vue" scheme="http://example.com/categories/Vue/"/>
    
    
    <category term="-Vue" scheme="http://example.com/tags/Vue/"/>
    
  </entry>
  
  <entry>
    <title>Vue路由的原理</title>
    <link href="http://example.com/2018/08/11/Vue%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86/"/>
    <id>http://example.com/2018/08/11/Vue%E8%B7%AF%E7%94%B1%E7%9A%84%E5%8E%9F%E7%90%86/</id>
    <published>2018-08-10T16:00:00.000Z</published>
    <updated>2022-10-13T02:32:11.330Z</updated>
    
    <content type="html"><![CDATA[<p>通过改变URL，在不重新请求页面的情况下，更新页面视图</p><p>更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能</p><p>的实现主要有2种方式</p><p>第一种是利用H5的historyAPI实现</p><p>主要是通过 history.pushstate和history.replacestate来实现，不同之处在于，pushstate</p><p>会增加一天新的历史记录 二replacestate 则会替代当前历史记录</p><p>第二种是利用url 的hash实现</p><p>我们经常在url中看到 # 这个#有俩种情况，一个是我们所谓的瞄点，路由里的#不叫瞄点</p><p>我们称之为hash，我们说的就是hash，主要是利用监听哈希值的变化触发事件–hashchange 事件来做页面局部更新</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;通过改变URL，在不重新请求页面的情况下，更新页面视图&lt;/p&gt;
&lt;p&gt;更新视图但不重新请求页面，是前端路由原理的核心之一，目前在浏览器环境中这一功能&lt;/p&gt;
&lt;p&gt;的实现主要有2种方式&lt;/p&gt;
&lt;p&gt;第一种是利用H5的historyAPI实现&lt;/p&gt;
&lt;p&gt;主要是通过 hi</summary>
      
    
    
    
    <category term="-vue" scheme="http://example.com/categories/vue/"/>
    
    
    <category term="-vue" scheme="http://example.com/tags/vue/"/>
    
  </entry>
  
  <entry>
    <title>有使用过vue吗 说说你对于vue的理解？</title>
    <link href="http://example.com/2018/07/15/%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87vue%E5%90%97-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8Evue%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/"/>
    <id>http://example.com/2018/07/15/%E6%9C%89%E4%BD%BF%E7%94%A8%E8%BF%87vue%E5%90%97-%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BA%8Evue%E7%9A%84%E7%90%86%E8%A7%A3%EF%BC%9F/</id>
    <published>2018-07-14T16:00:00.000Z</published>
    <updated>2022-10-10T10:39:23.886Z</updated>
    
    <content type="html"><![CDATA[<p>vue 是一用于构建用户界面的Javascript 库 也是一个创建单页面应用的框架</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;vue 是一用于构建用户界面的Javascript 库 也是一个创建单页面应用的框架&lt;/p&gt;
</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>async 函数是什么 有什么作用</title>
    <link href="http://example.com/2018/07/07/async-%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/"/>
    <id>http://example.com/2018/07/07/async-%E5%87%BD%E6%95%B0%E6%98%AF%E4%BB%80%E4%B9%88-%E6%9C%89%E4%BB%80%E4%B9%88%E4%BD%9C%E7%94%A8/</id>
    <published>2018-07-06T16:00:00.000Z</published>
    <updated>2022-10-10T08:44:30.683Z</updated>
    
    <content type="html"><![CDATA[<p>async 和await 主要是用于解决异步操作的一种方案</p><p>异步函数不会阻塞后续代码的执行 async 会默认的返回一个promise 对象  </p><p>而await 就是async 返回promise 对象的结果</p><p>如果好获取async 里的数据 使用 .then 和 .watch 来注册异步函数</p><p>await 是需要定义在异步函数内部的 当异步操作执行的时候遇到await会暂停   当异步函数执行完成之后</p><p>await 在继续执行</p><p>.async函数配合await关键字使用(阻塞代码往下执行)<br>是异步方法，但是阻塞式的</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;async 和await 主要是用于解决异步操作的一种方案&lt;/p&gt;
&lt;p&gt;异步函数不会阻塞后续代码的执行 async 会默认的返回一个promise 对象  &lt;/p&gt;
&lt;p&gt;而await 就是async 返回promise 对象的结果&lt;/p&gt;
&lt;p&gt;如果好获取async 里</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>异步操作有哪些</title>
    <link href="http://example.com/2018/07/06/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B/"/>
    <id>http://example.com/2018/07/06/%E5%BC%82%E6%AD%A5%E6%93%8D%E4%BD%9C%E6%9C%89%E5%93%AA%E4%BA%9B/</id>
    <published>2018-07-05T16:00:00.000Z</published>
    <updated>2022-10-10T08:39:03.789Z</updated>
    
    <content type="html"><![CDATA[<p>回调函数 </p><p>事件监听</p><p>  promise</p><p> ajax </p><p>async </p><p> setTimeout</p><p> Generator</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;回调函数 &lt;/p&gt;
&lt;p&gt;事件监听&lt;/p&gt;
&lt;p&gt;  promise&lt;/p&gt;
&lt;p&gt; ajax &lt;/p&gt;
&lt;p&gt;async &lt;/p&gt;
&lt;p&gt; setTimeout&lt;/p&gt;
&lt;p&gt; Generator&lt;/p&gt;
</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>说说webpack中常见的Loader？解决了什么问题？</title>
    <link href="http://example.com/2018/07/05/%E8%AF%B4%E8%AF%B4webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Loader%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/"/>
    <id>http://example.com/2018/07/05/%E8%AF%B4%E8%AF%B4webpack%E4%B8%AD%E5%B8%B8%E8%A7%81%E7%9A%84Loader%EF%BC%9F%E8%A7%A3%E5%86%B3%E4%BA%86%E4%BB%80%E4%B9%88%E9%97%AE%E9%A2%98%EF%BC%9F/</id>
    <published>2018-07-04T16:00:00.000Z</published>
    <updated>2022-10-10T08:31:17.446Z</updated>
    
    <content type="html"><![CDATA[<p>loader 用于对模块的源代码进行转换 在import或 “加载” 模块时预处理文件</p><p>style-loader 讲css添加到dom 的内联样式标签style里</p><p>css-loader 允许讲css文件通过require的方式引入 并返回css代码</p><p>less-loader 处理less</p><p>sass-loader 处理sass</p><p>postcss-loader 用postcss来处理css</p><p>autoprefixer-loader 处理css3属性前缀 已被弃用 建议直接使用postcss</p><p>file-loader 分发文件导uotput目录并返回想对路劲</p><p>url-loader和file-loader 类似，但是当文件小于设定的limit时返回一个Data url</p><p>html-minify-loader 压缩HTML</p><p>babel-loader 用loader来转换ES6文件到Es5</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;loader 用于对模块的源代码进行转换 在import或 “加载” 模块时预处理文件&lt;/p&gt;
&lt;p&gt;style-loader 讲css添加到dom 的内联样式标签style里&lt;/p&gt;
&lt;p&gt;css-loader 允许讲css文件通过require的方式引入 并返回css代</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>说说你对promise的了解</title>
    <link href="http://example.com/2018/07/05/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9promise%E7%9A%84%E4%BA%86%E8%A7%A3/"/>
    <id>http://example.com/2018/07/05/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9promise%E7%9A%84%E4%BA%86%E8%A7%A3/</id>
    <published>2018-07-04T16:00:00.000Z</published>
    <updated>2022-10-10T08:35:22.101Z</updated>
    
    <content type="html"><![CDATA[<p>1.异步操作的解决方案</p><p>Promise 是一种异步操作的解决方案，将写法复杂的传统的回调函数和监听事件的异</p><p>步操作，用同步代码的形式表达出来。避免了多级异步操作的回调函数嵌套。</p><p>主要用于异步计算</p><p>\2. 作为对象，内部有三种状态</p><p>初始状态（ pending ）。</p><p>已完成（ resolve）：resolve 方法可以使 Promise 对象的状态改变成成功</p><p>已拒绝（ reject ）：reject 方法则是将 Promise 对象的状态改变为失败</p><p>3.常用的三种方法</p><p>第一种：then 表示异步成功执行后的数据状态变为 resolve</p><p>第二种：catch 表示异步失败后执行的数据状态变为 reject</p><p>第三种：all 表示把多个没有关系的 Promise 封装成一个 Promise 对象，使用</p><p>then 返回一个数组数据。</p><p>5.在哪里使用过</p><p>Ajax 异步请求的时候</p><p>函数嵌套层级多的时候使用 promise，优点在于，回调函数变成了链式写法，程序的</p><p>流程可以看得很清楚，而且有一整套的配套方法，可以实现许多强大的功能。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.异步操作的解决方案&lt;/p&gt;
&lt;p&gt;Promise 是一种异步操作的解决方案，将写法复杂的传统的回调函数和监听事件的异&lt;/p&gt;
&lt;p&gt;步操作，用同步代码的形式表达出来。避免了多级异步操作的回调函数嵌套。&lt;/p&gt;
&lt;p&gt;主要用于异步计算&lt;/p&gt;
&lt;p&gt;\2. 作为对象，内部</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>谈谈你对webpack的看法</title>
    <link href="http://example.com/2018/07/03/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%9C%8B%E6%B3%95/"/>
    <id>http://example.com/2018/07/03/%E8%B0%88%E8%B0%88%E4%BD%A0%E5%AF%B9webpack%E7%9A%84%E7%9C%8B%E6%B3%95/</id>
    <published>2018-07-02T16:00:00.000Z</published>
    <updated>2022-10-10T08:20:46.213Z</updated>
    
    <content type="html"><![CDATA[<p>webpack是用来管理模块包的工具，在项目开发中可以打包模块依赖，对静态资源进行解析。在web开发过程中打包ht js css等静态资源，开发更加高效。对于不同类型的资源，webpack有模块加载器对模块包分析他们之间的依赖关系，最终优化合并为静态资源</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;webpack是用来管理模块包的工具，在项目开发中可以打包模块依赖，对静态资源进行解析。在web开发过程中打包ht js css等静态资源，开发更加高效。对于不同类型的资源，webpack有模块加载器对模块包分析他们之间的依赖关系，最终优化合并为静态资源&lt;/p&gt;
</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>XML和JSON的区别</title>
    <link href="http://example.com/2018/07/02/29-XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/07/02/29-XML%E5%92%8CJSON%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-07-01T16:00:00.000Z</published>
    <updated>2022-10-10T08:18:01.088Z</updated>
    
    <content type="html"><![CDATA[<p>XML和JSON的区别</p><p> XML是<a href="https://so.csdn.net/so/search?q=%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80&spm=1001.2101.3001.7020">可扩展标记语言</a>，标记语言就是通过一个一个的标记来组织数据的一种语法格式。</p><p>JSON是一种轻量级的数据交换格式，可使人们很容易地进行阅读和编写，同时也方便了机器进行解析和生成。JSON适用于进行数据交互的场景，如网站前台与后台之间的数据交互。</p><p>数据交互 json比xml交互更好，容易被解析</p><p>传输速度 json比xml传输速度更快</p><p>数据描述 json比xml描述更细致</p><p>体积 json比xml体积小，传输速度快</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;XML和JSON的区别&lt;/p&gt;
&lt;p&gt; XML是&lt;a href=&quot;https://so.csdn.net/so/search?q=%E5%8F%AF%E6%89%A9%E5%B1%95%E6%A0%87%E8%AE%B0%E8%AF%AD%E8%A8%80&amp;spm=1001</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>如何解决跨域问题</title>
    <link href="http://example.com/2018/06/30/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/"/>
    <id>http://example.com/2018/06/30/%E5%A6%82%E4%BD%95%E8%A7%A3%E5%86%B3%E8%B7%A8%E5%9F%9F%E9%97%AE%E9%A2%98/</id>
    <published>2018-06-29T16:00:00.000Z</published>
    <updated>2022-10-07T08:07:35.316Z</updated>
    
    <content type="html"><![CDATA[<p>代理跨域的原理 通过一些方法设置代理，在请求发送(接收)之前加入中间层，</p><p>客户端发送请求时</p><p>不直接到服务器</p><p>而是先到代理的中间层</p><p>再将请求发送到服务器</p><p>同理，当服务器返回数据的时候，也是先到代理的中间层</p><p> 出于浏览器的同源策略限制。同源策略（Sameoriginpolicy）是一种约定，它是浏览器最核心也最基本的安全功能，如果缺少了同源策略，则浏览器的正常功能可能都会受到影响。</p><p>通过jsonp跨域</p><p>document.domain + iframe跨域</p><p>nginx代理跨域</p><p>nodejs中间件代理跨域</p><p>后端在头部信息里面设置安全域名</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;代理跨域的原理 通过一些方法设置代理，在请求发送(接收)之前加入中间层，&lt;/p&gt;
&lt;p&gt;客户端发送请求时&lt;/p&gt;
&lt;p&gt;不直接到服务器&lt;/p&gt;
&lt;p&gt;而是先到代理的中间层&lt;/p&gt;
&lt;p&gt;再将请求发送到服务器&lt;/p&gt;
&lt;p&gt;同理，当服务器返回数据的时候，也是先到代理的中间层&lt;</summary>
      
    
    
    
    <category term="-JS Vue" scheme="http://example.com/categories/JS-Vue/"/>
    
    
    <category term="-JS Vue" scheme="http://example.com/tags/JS-Vue/"/>
    
  </entry>
  
  <entry>
    <title>谈一谈箭头函数与普通函数的区别</title>
    <link href="http://example.com/2018/06/21/%E8%B0%88%E4%B8%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/"/>
    <id>http://example.com/2018/06/21/%E8%B0%88%E4%B8%80%E8%B0%88%E7%AE%AD%E5%A4%B4%E5%87%BD%E6%95%B0%E4%B8%8E%E6%99%AE%E9%80%9A%E5%87%BD%E6%95%B0%E7%9A%84%E5%8C%BA%E5%88%AB/</id>
    <published>2018-06-20T16:00:00.000Z</published>
    <updated>2022-10-07T08:09:42.811Z</updated>
    
    <content type="html"><![CDATA[<p>1：写法不一样</p><p>2：普通函数存在变量提升的现象</p><p>3：箭头函数是匿名函数，不能作为构造函数使用，不能使用new。</p><p>匿名函数它是matlab中定义的一种函数形式，出现在matlab中，匿名函数不以文件形式驻留在文件夹上；他的生成方式最简捷，可在指令窗或任何函数体内通过指令直接生成。</p><p>匿名函数的作用主要是实现自己定义matlab中的函数，从而扩大函数的使用功能</p><p>4：两者this的指向不同</p><p>5：箭头函数的arguments指向它的父级函数所在作用域的arguments</p><p>6：箭头函数没有new.target</p><p>箭头函数</p><p>箭头函数的this指向父级作用域的this，</p><p>箭头函数没有prototype原型.</p><p>箭头函数不能作为构造函数。</p><p>普通函数的this</p><p>1、普通函数最终指向调用它的对象，也就是说谁调用就指向谁。</p><p>2、没有被对象调用的函数默认指向windows</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1：写法不一样&lt;/p&gt;
&lt;p&gt;2：普通函数存在变量提升的现象&lt;/p&gt;
&lt;p&gt;3：箭头函数是匿名函数，不能作为构造函数使用，不能使用new。&lt;/p&gt;
&lt;p&gt;匿名函数它是matlab中定义的一种函数形式，出现在matlab中，匿名函数不以文件形式驻留在文件夹上；他的生成方式最简</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>javascript 代码中的use strict;是什么意思</title>
    <link href="http://example.com/2018/06/20/javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84use-strict-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/"/>
    <id>http://example.com/2018/06/20/javascript-%E4%BB%A3%E7%A0%81%E4%B8%AD%E7%9A%84use-strict-%E6%98%AF%E4%BB%80%E4%B9%88%E6%84%8F%E6%80%9D/</id>
    <published>2018-06-19T16:00:00.000Z</published>
    <updated>2022-10-07T08:04:36.016Z</updated>
    
    <content type="html"><![CDATA[<p>use strict是es5中的严格模式，利用严格模式使代码编写更加规范，避免不合理的语法，和一些异常操作</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;use strict是es5中的严格模式，利用严格模式使代码编写更加规范，避免不合理的语法，和一些异常操作&lt;/p&gt;
</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>new操作符具体干了什么</title>
    <link href="http://example.com/2018/06/16/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/"/>
    <id>http://example.com/2018/06/16/new%E6%93%8D%E4%BD%9C%E7%AC%A6%E5%85%B7%E4%BD%93%E5%B9%B2%E4%BA%86%E4%BB%80%E4%B9%88/</id>
    <published>2018-06-15T16:00:00.000Z</published>
    <updated>2022-10-07T08:05:22.048Z</updated>
    
    <content type="html"><![CDATA[<p>创建一个新对象 作为返回的实列对象</p><p>将空对象的原型proto指向构造函数的prototype属性</p><p>对象连接到构造函数原型上 并绑定this （this指向新对象）</p><p>执行构造函数代码（为这个新对象添加属性）</p><p>返回新对象</p><p>（1）首先创建一个新的对象</p><p>（2）设置原型 将对象的原型设置为函数的prototype对象</p><p>（3） 让函数的this指向这个对象 执行构造函数的代码（为这个新对象添加属性）</p><p>(4) 判断函数的返回值类型 ，如果是值类型 返回创建的对象 如果是引用数据类型 就返回</p><p>这个引用数据类型</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;创建一个新对象 作为返回的实列对象&lt;/p&gt;
&lt;p&gt;将空对象的原型proto指向构造函数的prototype属性&lt;/p&gt;
&lt;p&gt;对象连接到构造函数原型上 并绑定this （this指向新对象）&lt;/p&gt;
&lt;p&gt;执行构造函数代码（为这个新对象添加属性）&lt;/p&gt;
&lt;p&gt;返回新对象&lt;</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>谈谈This对象的理解</title>
    <link href="http://example.com/2018/06/15/%E8%B0%88%E8%B0%88This%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2018/06/15/%E8%B0%88%E8%B0%88This%E5%AF%B9%E8%B1%A1%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2018-06-14T16:00:00.000Z</published>
    <updated>2022-10-07T08:09:34.815Z</updated>
    
    <content type="html"><![CDATA[<p>在浏览器里，在全局范围内 指向window对象；</p><p>在函数中，this永远指向最后调用他的那个对象；</p><p>构造函数中，this指向new出来的那个新的对象；</p><p>call、apply、bind中的this被强绑定在指定的那个对象上；</p><p>箭头函数中this比较特殊,箭头函数this为父作用域的this，而箭头函数的this指向是静态的,声明的时候就确定了下来；</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;在浏览器里，在全局范围内 指向window对象；&lt;/p&gt;
&lt;p&gt;在函数中，this永远指向最后调用他的那个对象；&lt;/p&gt;
&lt;p&gt;构造函数中，this指向new出来的那个新的对象；&lt;/p&gt;
&lt;p&gt;call、apply、bind中的this被强绑定在指定的那个对象上；&lt;/p&gt;
</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>什么是事件代理</title>
    <link href="http://example.com/2018/06/14/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/"/>
    <id>http://example.com/2018/06/14/%E4%BB%80%E4%B9%88%E6%98%AF%E4%BA%8B%E4%BB%B6%E4%BB%A3%E7%90%86/</id>
    <published>2018-06-13T16:00:00.000Z</published>
    <updated>2022-10-07T08:08:25.973Z</updated>
    
    <content type="html"><![CDATA[<p>事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件 委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。</p><p>使用事件代理的好处是可以提高性能可以大量节省内存占用，减少事件注册</p><p>可以实现当新增子对象时无需再次对其绑定</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;事件代理（Event Delegation），又称之为事件委托。是 JavaScript 中常用绑定事件的常用技巧。顾名思义，“事件代理”即是把原本需要绑定的事件 委托给父元素，让父元素担当事件监听的职务。事件代理的原理是DOM元素的事件冒泡。&lt;/p&gt;
&lt;p&gt;使用事件代理的</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>JavaScript原型，原型链 ? 有什么特点？</title>
    <link href="http://example.com/2018/06/13/JavaScript%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/"/>
    <id>http://example.com/2018/06/13/JavaScript%E5%8E%9F%E5%9E%8B%EF%BC%8C%E5%8E%9F%E5%9E%8B%E9%93%BE-%E6%9C%89%E4%BB%80%E4%B9%88%E7%89%B9%E7%82%B9%EF%BC%9F/</id>
    <published>2018-06-12T16:00:00.000Z</published>
    <updated>2022-10-07T08:04:44.456Z</updated>
    
    <content type="html"><![CDATA[<p><em><strong>*原型：*</strong></em></p><p>JavaScript的所有对象中都包含了一个 [<strong>proto</strong>] 内部属性，这个属性所对应的就是该对象的原型</p><p>JavaScript的函数对象，除了原型 [<strong>proto</strong>] 之外，还预置了 prototype 属性</p><p>当函数对象作为构造函数创建实例时，该 prototype 属性值将被作为实例对象的原型 [<strong>proto</strong>]。</p><p><em><strong>*原型链：*</strong></em></p><p>当一个对象调用的属性/方法自身不存在时，就会去自己 [<strong>proto</strong>] 关联的前辈 prototype 对象上去找</p><p>如果没找到，就会去该 prototype 原型 [<strong>proto</strong>] 关联的前辈 prototype 去找。依次类推，直到找到属性/方法或 undefined 为止。从而形成了所谓的“原型链”</p><p><em><strong>*原型特点：*</strong></em></p><p>JavaScript对象是通过引用来传递的，当修改原型时，与之相关的对象也会继承这一改变</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;em&gt;&lt;strong&gt;*原型：*&lt;/strong&gt;&lt;/em&gt;&lt;/p&gt;
&lt;p&gt;JavaScript的所有对象中都包含了一个 [&lt;strong&gt;proto&lt;/strong&gt;] 内部属性，这个属性所对应的就是该对象的原型&lt;/p&gt;
&lt;p&gt;JavaScript的函数对象，除了原型 </summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>说说你对作用域的理解</title>
    <link href="http://example.com/2018/06/13/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/"/>
    <id>http://example.com/2018/06/13/%E8%AF%B4%E8%AF%B4%E4%BD%A0%E5%AF%B9%E4%BD%9C%E7%94%A8%E5%9F%9F%E7%9A%84%E7%90%86%E8%A7%A3/</id>
    <published>2018-06-12T16:00:00.000Z</published>
    <updated>2022-10-07T08:09:23.295Z</updated>
    
    <content type="html"><![CDATA[<p>作用域就是变量 变量又称上下文 </p><p>简单来说 作用域的就是变量和函数的可访问行 即控制着 变量和函数的可见性和生命周期</p><p>在Es5 之间 作用域分为俩种 全局作用域和函数作用域</p><p>全局作用域：全局作用域中的对象在代码中的任何一个地方都可以被访问到</p><p>函数作用域：就是在函数内部定义变量和参数 且只能在函数内部被访问到</p><p>块级作用域：就是被有段大括号包裹的一段代码 比如：函数  判断语句 循环语句  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;作用域就是变量 变量又称上下文 &lt;/p&gt;
&lt;p&gt;简单来说 作用域的就是变量和函数的可访问行 即控制着 变量和函数的可见性和生命周期&lt;/p&gt;
&lt;p&gt;在Es5 之间 作用域分为俩种 全局作用域和函数作用域&lt;/p&gt;
&lt;p&gt;全局作用域：全局作用域中的对象在代码中的任何一个地方都可以</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
  <entry>
    <title>通过js判断数组</title>
    <link href="http://example.com/2018/06/12/%E9%80%9A%E8%BF%87js%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/"/>
    <id>http://example.com/2018/06/12/%E9%80%9A%E8%BF%87js%E5%88%A4%E6%96%AD%E6%95%B0%E7%BB%84/</id>
    <published>2018-06-11T16:00:00.000Z</published>
    <updated>2022-10-07T08:09:51.158Z</updated>
    
    <content type="html"><![CDATA[<p>1.Es5 新增的方法IsArray（）、</p><p>2.Instanceof 方法 是用来检测一个对象是否在其原型链原型构造函数的属性  </p><p>​    用于检验构造函数的prototype属性是否出现在对象的原型链中的属性</p><ol start="3"><li>Constructor 方法 返回对创建此对象的数组函数的引用 就是返回对象对应的构造函数</li><li>JQuery 正在使用的 object.protype.tostring.call（）返回数据类型的方法</li><li></li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;1.Es5 新增的方法IsArray（）、&lt;/p&gt;
&lt;p&gt;2.Instanceof 方法 是用来检测一个对象是否在其原型链原型构造函数的属性  &lt;/p&gt;
&lt;p&gt;​    用于检验构造函数的prototype属性是否出现在对象的原型链中的属性&lt;/p&gt;
&lt;ol start=&quot;3</summary>
      
    
    
    
    <category term="-JS" scheme="http://example.com/categories/JS/"/>
    
    
    <category term="-JS" scheme="http://example.com/tags/JS/"/>
    
  </entry>
  
</feed>
